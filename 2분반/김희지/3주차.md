# 📌3주차

## 20. 자바스크립트 - 반복문

- for문
- while문: while(불리언 값){ 반복 실행해야 하는 명령문들}
- do~while문
- 무한루프에 빠진 경우
    
    ctrl+c를 통해 프로그램 종료하면 됨
    
    프로그램이 무한루프에 빠지면 시스템의 리소스를 많이 소비하면서 자칫 위험한 상황을 초래할 수 있음. 개발자가 의도하지 않은 무한 루프는 심각한 오류
    
    이를 방지하기 위해 반복 조건을 언젠가는 false로 바꿔 빠져나올 수 있도록 해야함
    

반복문 예시 코드:

```jsx
`console.log('A');`

`console.log('B');`

**`var** i = 0;`

**`while**(i < 2){//100번 반복하고 싶으면 i<100`

`console.log('C1');`

`console.log('C2');`

`i = i + 1;`

`}`

`console.log('D');`
```

## 21. 자바스크립트 - 배열

프로그램을 작성하다보면 폭발적으로 데이터가 많아지는데 이를 관리해줄 수 있는 도구가 바로 배열임.

### 배열 만들기

1. 배열을 생성한 다음 변수에 넣기 (이때 배열 안에는 문자열 뿐 아니라 숫자든 불리언이든 모두 넣을 수 있음)

```jsx
**var** arr = ['A','B','C','D']; //대괄호를 넣어서 배열을 만들고 ,로 구분하여 데이터를 넣음
```

### 배열 에서 값 읽기

```jsx
console.log(arr);
```

- 인덱스는 0부터 시작

### 배열에서 특정 값만 읽어오기

```jsx
`console.log(arr[1]);`

`console.log(arr[3]);`
```

### 배열에서 값 갱신하기

```jsx
arr[2] = 3;
```

### 배열의 크기 구하기

```jsx
console.log(arr.length);
```

### 배열의 마지막에 값 추가

```jsx
arr.push('E');
```

## 22. 자바스크립트 - 배열과 반복문

```jsx
var number = [1,400,12,34];//배열 생성
var i = 0;//변수 초기화
var total = 0;//합계를 저장할 변수 초기화
while(i < number.length){//배열의 길이만큼 반복
  total = total + number[i];//배열 안 원소들을 더함
  i = i + 1;
}
console.log(`total : ${total}`);//total 변수 값 출력
```

## 23. Node.js - 파일 목록 알아내기

```jsx
var testFolder = './data';//우리가 조사할 디렉터리 경로 지정
var fs = require('fs');//fs 모듈 사용
 
fs.readdir(testFolder, function(error, filelist){
  console.log(filelist);
})
```

- readdir은 특정 디렉터리에 있는 파일 목록을 배열로 돌려줌

## 24. App - 글 목록 출력하기

- readdir은 data 디렉터리에 있는 파일 목록을 가져온 다음 functio() {} 안에 있는 코드를 실행하도록 약속되어있음

```jsx
var http = require('http');
var fs = require('fs');
var url = require('url');
 
var app = http.createServer(function(request,response){
    var _url = request.url;
    var queryData = url.parse(_url, true).query;
    var pathname = url.parse(_url, true).pathname;
    if(pathname === '/'){
      if(queryData.id === undefined){
 
        **fs.readdir('./data', function(error, filelist){
        //웹페이지를 출력하는 코드를 readdir 영역으로 옮김
          var title = 'Welcome';
          var description = 'Hello, Node.js';
          var list = '<ul>';
          var i = 0;
          while(i < filelist.length){
            list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
            i = i + 1;
            //목록을 만드는 태그 추가**
          }
          list = list+'</ul>';
          var template = `
          <!doctype html>
          <html>
          <head>
            <title>WEB1 - ${title}</title>
            <meta charset="utf-8">
          </head>
          <body>
            <h1><a href="/">WEB</a></h1>
            **${list}
           //data 디렉터리 파일 목록을 표시하는 HTML 코드가 list 변수에 저장됐으므로 저장한 변수를 웹페이지에 표시하기 위해 코드 변경**
            <h2>${title}</h2>
            <p>${description}</p>
          </body>
          </html>
          `;
          response.writeHead(200);
          response.end(template);
        })
 
 
 
      } else {//쿼리스트링이 있을 때도 동적으로 목록을 바꾸도록 변경
        **fs.readdir('./data', function(error, filelist){
          var title = 'Welcome';
          var description = 'Hello, Node.js';
          var list = '<ul>';
          var i = 0;
          while(i < filelist.length){
            list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
            i = i + 1;**
          }
          list = list+'</ul>';
          fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
            var title = queryData.id;
            var template = `
            <!doctype html>
            <html>
            <head>
              <title>WEB1 - ${title}</title>
              <meta charset="utf-8">
            </head>
            <body>
              <h1><a href="/">WEB</a></h1>
              ${list}
              <p>${description}</p>
            </body>
            </html>
            `;
            response.writeHead(200);
            response.end(template);
          });
        });
      }
    } else {
      response.writeHead(404);
      response.end('Not found');
    }
 
 
 
});
app.listen(3000);
```

## 25. 자바스크립트 - 함수

**함수**는 어떤 기능, 일련의 로직에 이름을 붙이는 것과 같음

기능에 이름을 붙여서 이 기능이 필요할 대마다 해당 이름으로 쉽게 사용할 수 있도록 만든 것

예를 들어 함수의 기능을 변경해야할 때, 함수를 정의한 부분만 수정하면 해당 함수를 사용한 모든 곳에 수정이 반영되어 유지보수가 편리해짐.

```jsx
f123();
console.log('A');
console.log('Z');
console.log('B');
f123();
console.log('F');
console.log('C');
console.log('P');
console.log('J');
f123();
console.log('U');
console.log('A');
console.log('Z');
console.log('J');
console.log('I');
f123();
 
function f123(){
  console.log(1);
  console.log(2);
  console.log(3);
  console.log(4);
}
 
```

→ 이처럼 반복해서 등장하는 부분은 함수를 정의하여 사용하는 것이 편리함( f123() )

- 함수를 정의하는 문법

```jsx
function 함수 이름 {
함수에서 실행할 코드
}

```

### 함수의 입력

함수는 입력받은 값에 따라 다르게 동작할 수 있어 출력이 다양해질 수 있음

```jsx
console.log(Math.round(1.6)); //2
console.log(Math.round(1.4)); //1
 
function sum(first, second){ // parameter
  console.log(first+second);
}
 
sum(2,4); // argument
```

- 이때 math는 자바스크립트에 내장된 객체, 코드에서는 Math 객체에 포함된 round 함수를 사용함
- round 함수는 입력값을 반올림해서 반환하는 함수
- function으로 함수를 정의할 때 입력값을 두 개 받도록 정의함. 따라서 이 함수를 호출할 땐 두 개의 값을 전달해야 함.
- 함수의 입력값으로 전달받는 변수(예제에서 first, second)를 **매개변수(parameter)**라고 하고, 2와 4 같은 함수 호출 시 전달하는 값을 **인자(argument)**라고 함.

### 함수의 출력

```jsx
console.log(Math.round(1.6)); //2
console.log(Math.round(1.4)); //1
 
function sum(first, second){ // parameter
  return first+second;
}
 
console.log(sum(2,4)); // argument
filewrite('result.txt', Math.round(1.6));// 파일에 저장
email('nitej304@naver.com', Math.round(1.6)); // 메일로 전송
```

- return문은 함수를 종료한다는 의미와 어떤 값을 반환한다는 두 가지 의미가 있는 명령임. 따라서 함수 내에서 return문 다음에 오는 명령은 생략하고 함수를 종료하므로 실행되지 않음.

## 26. App - 함수를 이용해 코드 정리하기

```jsx
var http = require('http');
var fs = require('fs');
var url = require('url');
 
function templateHTML(title, list, body){//제목, 글 목록, 본문
//사용자가 요청한 페이지를 HTML로 만들어주는 부분
  return `
  <!doctype html>
  <html>
  <head>
    <title>WEB1 - ${title}</title>
    <meta charset="utf-8">
  </head>
  <body>
    <h1><a href="/">WEB</a></h1>
    ${list}
    ${body}
  </body>
  </html>
  `;
}
function templateList(filelist){
//list 변수를 정의하는 부분, data 디렉터리에 있는 파일을 목록으로 보여주는 HTML 코드가 저장되는 부분임
  var list = '<ul>';
  var i = 0;
  while(i < filelist.length){
    list = list + `<li><a href="/?id=${filelist[i]}">${filelist[i]}</a></li>`;
    i = i + 1;
  }
  list = list+'</ul>';
  return list;//return문으로 list를 반환
}
 
var app = http.createServer(function(request,response){
    var _url = request.url;
    var queryData = url.parse(_url, true).query;
    var pathname = url.parse(_url, true).pathname;
    if(pathname === '/'){
      if(queryData.id === undefined){
        fs.readdir('./data', function(error, filelist){
          var title = 'Welcome';
          var description = 'Hello, Node.js';
          var list = templateList(filelist);
          var template = templateHTML(title, list, `<h2>${title}</h2>${description}`);
          response.writeHead(200);
          response.end(template);
        })
      } else {
        fs.readdir('./data', function(error, filelist){
          fs.readFile(`data/${queryData.id}`, 'utf8', function(err, description){
            var title = queryData.id;
            var list = templateList(filelist);
            var template = templateHTML(title, list, `<h2>${title}</h2>${description}`);
            response.writeHead(200);
            response.end(template);
          });
        });
      }
    } else {
      response.writeHead(404);
      response.end('Not found');
    }
 
 
 
});
app.listen(3000);
```

→ 중복되는 코드를 templateHTML과 templateList 함수를 만들어 처리함

## 28. Node.js - 동기와 비동기, 콜백

### 동기와 비동기 1

- 동기 처리 방식**(synchronous):** 하나의 작업이 끝날 때까지 기다렸다가 다음 작업을 처리하는 방식
- 비동기 처리 방식**(asynchronous):** 병렬로 동시에 여러 가지 일을 처리하는 방식

### 동기와 비동기2

- 동기로 처리: 모듈 기능 이름에 **Sync**가 있음
- 비동기로 처리: Sync가 없음

```jsx
var fs = require('fs');
 
/*
//readFileSync
console.log('A');
var result = fs.readFileSync('syntax/sample.txt', 'utf8');
console.log(result);
console.log('C');
*/
//동기인 경우
 
 
console.log('A');
fs.readFile('syntax/sample.txt', 'utf8', function(err, result){
    console.log(result);
});
console.log('C');
//비동기인 경우
 
```

- 비동기 처리 방식으로 동작하는  readFile 기능은 실행 흐름과 별도로 동작하여 처리 시간이 실행 흐름에 영향을 미치지 않음
- Node.js의 성능을 제대로 끌어올리려면 비동기 처리 방식을 사용해야 함.

### 콜백

어떤 실행문을 마치면 내부적으로 자동 호출하는 기능

```jsx
/*
function a(){
  console.log('A');
}
*/
var a = function(){
  console.log('A');
}
 
 
function slowfunc(callback){
  callback();
}
 
slowfunc(a);
```

- 자바스크립트에서는 함수가 값
- a 변수 뒤에 함수 호출 연산자 ()를 지정함으로써 a 변수에 담긴 함수를 호출할 수 있게 됨.
- slowfunc(a);는 slowfunc 함수의 실행이 끝나면 자동으로 a 함수를 호출해 달라고 하는 것. slowfunc 함수는 callback을 매개변수로 받아서 호출하기 때문
